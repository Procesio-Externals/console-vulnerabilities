using System.Security.Cryptography;
using System.Text;

namespace VulnerableSolution
{
    public class Encryption
    {
        public static void Execute()
        {
            // Generate the RSA key pair with 512-bit key size
            // key is too short for production use. 2048-bit key size is recommended
            using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(512))
            {
                try
                {
                    // Export the public key and private key
                    string publicKey = rsa.ToXmlString(false);  // Public key only
                    string privateKey = rsa.ToXmlString(true);  // Public and private keys

                    Console.WriteLine("Public Key: \n" + publicKey);
                    Console.WriteLine("Private Key: \n" + privateKey);

                    // Message to encrypt
                    string originalMessage = "This is a test message";
                    Console.WriteLine("Original Message: " + originalMessage);

                    // Encrypt the message using the public key
                    byte[] encryptedMessage = EncryptMessage(originalMessage, rsa);

                    // Decrypt the message using the private key
                    string decryptedMessage = DecryptMessage(encryptedMessage, rsa);

                    // Output the encrypted and decrypted messages
                    Console.WriteLine("\nEncrypted Message (Base64): " + Convert.ToBase64String(encryptedMessage));
                    Console.WriteLine("\nDecrypted Message: " + decryptedMessage);
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Error: " + ex.Message);
                }
            }
        }

        static byte[] EncryptMessage(string message, RSACryptoServiceProvider rsa)
        {
            // Convert the message to a byte array
            byte[] messageBytes = Encoding.UTF8.GetBytes(message);

            // Encrypt the message with the public key
            byte[] encryptedMessage = rsa.Encrypt(messageBytes, false); // false for OAEP padding (deprecated in RSA)

            return encryptedMessage;
        }

        static string DecryptMessage(byte[] encryptedMessage, RSACryptoServiceProvider rsa)
        {
            // Decrypt the message using the private key
            byte[] decryptedBytes = rsa.Decrypt(encryptedMessage, false); // false for OAEP padding (deprecated in RSA)

            // Convert the decrypted byte array to a string
            return Encoding.UTF8.GetString(decryptedBytes);
        }

        // library considers Rfc2898DeriveBytes default hash algorithm as insecure and outdated
        public static string Encrypt(string input, string? privateKey = null)
        {
            privateKey ??= "abcdefghijklmnopq";

            if (string.IsNullOrEmpty(input))
                return string.Empty;

            var plainTextInBytes = Encoding.UTF8.GetBytes(input);
            // Declare the string used to hold the encrypted text.
            byte[] encrypted;

            //Create an Aes object with the specified key and IV.
            using var aes = Aes.Create();
            aes.GenerateIV();
            var IV = aes.IV;

            //The Salt will be the first 8 bytes of the IV.
            var theSalt = new byte[8];
            Array.Copy(IV, theSalt, 8);

            //A key for AES is generated by expanding the password using the following method.
            var keyGen = new Rfc2898DeriveBytes(privateKey, theSalt);
            var aesKey = keyGen.GetBytes(16);
            aes.Key = aesKey;

            // Create a encryptor to perform the stream transform.
            var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

            // Create the streams used for encryption. 
            using (var memoryStreamEncrypt = new MemoryStream())
            {
                using var cryptoStreamEncrypt =
                    new CryptoStream(memoryStreamEncrypt, encryptor, CryptoStreamMode.Write);
                using (var writerEncrypt = new BinaryWriter(cryptoStreamEncrypt))
                {
                    //Write all data to the stream.
                    writerEncrypt.Write(plainTextInBytes);
                }

                encrypted = memoryStreamEncrypt.ToArray();
            }

            // Prepend the IV to the cipher text, so it can be used in the decryption process.
            using var ivPlusCipher = new MemoryStream();
            using (var tBinaryWriter = new BinaryWriter(ivPlusCipher))
            {
                tBinaryWriter.Write(IV);
                tBinaryWriter.Write(encrypted);
                tBinaryWriter.Flush();
            }

            return Convert.ToBase64String(ivPlusCipher.ToArray());
        }
    }
}
